<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gianmarco: Brown Bed Blitz</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --ink:#e5e7eb;  /* gray-200 */
      --accent:#f59e0b; /* amber-500 */
      --good:#22c55e; /* green-500 */
      --warn:#ef4444; /* red-500 */
      --info:#60a5fa; /* blue-400 */
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:radial-gradient(1200px 800px at 70% -10%, #1f2937, #0b1022 60%, #050813 100%);color:var(--ink);height:100vh;display:flex;flex-direction:column;}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0));backdrop-filter:blur(6px);position:sticky;top:0;z-index:5}
    header h1{font-size:18px;margin:0;letter-spacing:.3px}
    header .btn{background:transparent;border:1px solid #334155;color:var(--ink);padding:6px 10px;border-radius:10px;cursor:pointer}
    main{display:grid;grid-template-columns:1fr 360px;gap:10px;flex:1;min-height:0;padding:10px}
    @media (max-width: 920px){main{grid-template-columns:1fr}}
    #gameWrap{position:relative;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35);} 
    #canvas{display:block;width:100%;height:100%;background:repeating-linear-gradient(45deg,#0b1228,#0b1228 18px,#0d1633 18px,#0d1633 36px)}
    .hud{position:absolute;inset:0;pointer-events:none}
    .hud .top{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:10px;flex-wrap:wrap}
    .chip{pointer-events:auto;background:#0b1228cc;border:1px solid #1f2a4a;color:var(--ink);padding:6px 10px;border-radius:999px;font-size:14px;display:flex;gap:8px;align-items:center}
    .chip .dot{width:8px;height:8px;border-radius:50%}
    .chip.good .dot{background:var(--good)}
    .chip.warn .dot{background:var(--warn)}
    .chip.time .dot{background:var(--accent)}
    .chip b{font-weight:700}
    #side{background:linear-gradient(180deg,#0c1226,#0a0f1f);border:1px solid #1b2443;border-radius:16px;padding:14px;display:flex;flex-direction:column;gap:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,.05)}
    #side h2{margin:0 0 4px 0;font-size:16px}
    #side p{margin:0;color:#cbd5e1}
    .card{background:#0b1228;border:1px solid #18234b;border-radius:14px;padding:12px}
    .row{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .k{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#0f172a;border:1px solid #1f2937;border-bottom-width:2px;padding:2px 6px;border-radius:8px}
    .primary{background:linear-gradient(180deg,#f59e0b,#d97706);color:#111827;border:none;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}
    .ghost{background:transparent;border:1px solid #334155;color:#cbd5e1;border-radius:12px;padding:10px 14px;cursor:pointer}
    footer{padding:10px;text-align:center;color:#94a3b8}

    /* Toast */
    #toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#0b1228cc;border:1px solid #1b2443;color:#e5e7eb;padding:10px 14px;border-radius:12px;opacity:0;pointer-events:none;transition:opacity .25s, transform .25s; z-index:20}
    #toast.show{opacity:1;transform:translateX(-50%) translateY(-6px)}

    /* Touch controls */
    #touch{position:absolute;inset:0;pointer-events:none}
    .joystick{position:absolute;bottom:20px;left:20px;width:120px;height:120px;border-radius:50%;background:#0b122888;border:1px solid #1f2a4a;pointer-events:auto}
    .stick{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:64px;height:64px;border-radius:50%;background:#0f172a;border:2px solid #1f2a4a}
    .action{position:absolute;bottom:40px;right:24px;width:80px;height:80px;border-radius:50%;background:#f59e0bcc;border:1px solid #f59e0b;display:grid;place-items:center;pointer-events:auto}
    .action span{font-weight:800;color:#0a0f1f}

    /* Start overlay */
    #startOverlay, #gameOver{position:absolute;inset:0;display:grid;place-items:center;background:radial-gradient(600px 400px at 50% 0%, rgba(245,158,11,.15), transparent 70%), linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.65));backdrop-filter:blur(2px)}
    .panel{max-width:520px;background:#0b1228;border:1px solid #1b2443;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .panel h3{margin:0 0 6px 0}
    .panel ul{margin:8px 0 0 18px}
    .center{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  </style>
</head>
<body>
  <header>
    <h1>üõèÔ∏è Gianmarco: <em>Brown Bed Blitz</em></h1>
    <div style="display:flex;gap:8px">
      <button class="btn" id="btnMute" aria-pressed="false">üîä Audio</button>
      <button class="btn" id="btnReset">‚Üª Reset</button>
    </div>
  </header>
  <main>
    <div id="gameWrap">
      <canvas id="canvas" width="960" height="600" aria-label="Arena di gioco"></canvas>
      <div class="hud">
        <div class="top">
          <div class="chip time"><span class="dot"></span>‚è≥ Tempo: <b id="time">60.0</b>s</div>
          <div class="chip good"><span class="dot"></span>‚úÖ Letti marroni: <b id="score">0</b></div>
          <div class="chip warn"><span class="dot"></span>üèÜ Record: <b id="best">0</b></div>
          <div class="chip"><span class="dot" style="background:var(--info)"></span>üî• Combo: <b id="combo">x1</b></div>
        </div>
      </div>

      <div id="touch">
        <div class="joystick" id="joy">
          <div class="stick" id="stick"></div>
        </div>
        <div class="action" id="act"><span>GO</span></div>
      </div>

      <div id="startOverlay">
        <div class="panel">
          <h3>Missione</h3>
          <p>Aiuta Gianmarco a rendere marroni pi√π letti possibile in 60 secondi. Avvic√¨nati ad un letto e premi <span class="k">SPAZIO</span> (o il bottone <em>GO</em> su mobile) per‚Ä¶ ehm‚Ä¶ completare l'opera.</p>
          <div class="card">
            <div class="row"><span>Muovi</span><span class="k">W A S D</span> / <span class="k">‚Üë ‚Üê ‚Üì ‚Üí</span></div>
            <div class="row"><span>Interazione</span><span class="k">SPAZIO</span> o click sul letto</div>
            <div class="row"><span>Combo</span><span>Catena rapida = <b>+tempo</b> e <b>moltiplicatore</b></span></div>
          </div>
          <div class="center" style="margin-top:8px">
            <button class="primary" id="btnStart">Inizia</button>
            <button class="ghost" id="btnHow">Regole</button>
          </div>
        </div>
      </div>

      <div id="gameOver" style="display:none">
        <div class="panel">
          <h3>Tempo scaduto!</h3>
          <p>Hai reso marroni <b id="finalScore">0</b> letti. Record: <b id="finalBest">0</b>.</p>
          <div class="center" style="margin-top:8px">
            <button class="primary" id="btnAgain">Gioca ancora</button>
            <button class="ghost" id="btnShare">Condividi</button>
          </div>
        </div>
      </div>

    </div>

    <aside id="side">
      <h2>Come si gioca</h2>
      <p>Sporca pi√π letti possibile prima che scada il tempo. Le combo ravvicinate aggiungono secondi e moltiplicatore.</p>
      <div class="card">
        <h3 style="margin:0 0 6px 0">Power‚Äëup</h3>
        <ul style="margin:0 0 0 18px">
          <li><b>‚è±Ô∏è Tempo+</b> aggiunge 5s</li>
          <li><b>üöÄ Scatto</b> velocit√† √ó1.8 per 5s</li>
          <li><b>üß≤ Magnet</b> interazione pi√π permissiva per 8s</li>
        </ul>
      </div>
      <div class="card">
        <h3 style="margin:0 0 6px 0">Consigli</h3>
        <ul style="margin:0 0 0 18px">
          <li>Punta ai cluster di letti per tenere viva la combo.</li>
          <li>Attiva il suono per un feedback pi√π soddisfacente üòÖ</li>
        </ul>
      </div>
      <div class="card" id="diagnostics">
        <h3 style="margin:0 0 6px 0">Diagnostica & Test</h3>
        <div class="row">
          <button class="ghost" id="btnTests">Esegui test</button>
          <span id="testSummary" aria-live="polite">Nessun test eseguito</span>
        </div>
        <pre id="testLog" style="margin-top:8px;max-height:200px;overflow:auto;background:#0f172a;border:1px solid #1f2937;border-radius:10px;padding:8px"></pre>
        <small id="web3Info" style="color:#94a3b8"></small>
      </div>
      <div class="row">
        <button class="ghost" id="btnFullscreen">Schermo intero</button>
        <button class="ghost" id="btnTheme">Tema</button>
      </div>
    </aside>
  </main>
  <footer>¬© 2025 Brown Bed Blitz ‚Äî by You & Gianmarco</footer>
  <div id="toast" role="status" aria-live="polite"></div>

  <script>
  // --- Utility ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  function toast(msg, ms=2200){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); clearTimeout(t._to); t._to=setTimeout(()=>t.classList.remove('show'), ms); }

  // --- Web3/MetaMask guard (robusto & in cattura) ---
  (function setupWeb3Guard(){
    window.__web3SuppressedCount = 0;
    const info = document.getElementById('web3Info');
    const hasEthereum = typeof window.ethereum !== 'undefined';
    if(info){
      info.textContent = hasEthereum
        ? 'Rilevato provider Web3 nel browser. Il gioco NON usa MetaMask: eventuali errori saranno ignorati.'
        : 'Nessun provider Web3 rilevato. Tutto ok.';
    }

    function shouldSuppress(raw){
      const msg = String(raw||'');
      return /metamask/i.test(msg) || /failed\s+to\s+connect\s+to\s+metamask/i.test(msg) || /-32002/.test(msg);
    }

    function handleSuppression(kind, msg, ev){
      try{ ev?.preventDefault?.(); }catch(_){}
      try{ ev?.stopPropagation?.(); }catch(_){}
      window.__web3SuppressedCount++;
      console.warn(`[Guard] Soppressa ${kind} Web3/MetaMask:`, msg);
      toast('Web3/MetaMask disabilitato per questo gioco.');
    }

    // Cattura precocemente errori e promise rejection (fase di cattura)
    window.addEventListener('error', (e)=>{
      const msg = e?.message || e?.error?.message || '';
      if(shouldSuppress(msg)) handleSuppression('error', msg, e);
    }, true);

    window.addEventListener('unhandledrejection', (e)=>{
      const msg = (e?.reason && (e.reason.message||String(e.reason))) || '';
      if(shouldSuppress(msg)) handleSuppression('unhandledrejection', msg, e);
    }, true);

    // Guard di emergenza: proteggi eventuali accessi diretti inattesi
    try{
      // Non tocchiamo window.ethereum se esiste, ma impediamo crash se qualche script lancia eccezioni sincrone al read.
      // (Nessuna azione necessaria qui, lasciamo solo il try/catch per future integrazioni.)
    }catch(e){ if(shouldSuppress(e?.message)) {/* swallow */} }
  })();

  // --- Audio ---
  const AudioKit = (()=>{
    let ctx, enabled=false;
    function ensure(){ try{ if(!ctx){ ctx = new (window.AudioContext||window.webkitAudioContext)(); } }catch(_){} }
    function beep(freq=220, dur=0.08, type='square', vol=0.04){ if(!enabled) return; ensure(); if(!ctx) return; try{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime+dur); }catch(_){} }
    function click(){ beep(440,0.05,'square',0.06) }
    function success(){ beep(180,0.06); setTimeout(()=>beep(240,0.08,'sawtooth',0.05),60) }
    function power(){ beep(520,0.12,'triangle',0.06) }
    function enable(v){ enabled=v; if(v) ensure(); }
    return { click, success, power, enable };
  })();

  // --- Game objects ---
  const canvas = document.getElementById('canvas');
  const ctx2d = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const arenaPad = 24; // padding inside canvas for spawning

  const state = {
    running:false,
    time:60,
    score:0,
    best:Number(localStorage.getItem('bbb-best')||0),
    combo:1,
    comboTimer:0,
    beds:[],
    powerups:[],
    player: {x:W/2,y:H/2, r:16, speed:180, vx:0, vy:0, scatto:0, magnet:0},
    lastTick:0,
  };

  const ui = {
    time: document.getElementById('time'),
    score: document.getElementById('score'),
    best: document.getElementById('best'),
    combo: document.getElementById('combo'),
    start: document.getElementById('startOverlay'),
    over: document.getElementById('gameOver'),
    finalScore: document.getElementById('finalScore'),
    finalBest: document.getElementById('finalBest'),
  };
  ui.best.textContent = state.best;

  function spawnBeds(n=20){
    state.beds = [];
    for(let i=0;i<n;i++){
      const w = rand(60,100), h=rand(40,70);
      const x = rand(arenaPad, W - arenaPad - w);
      const y = rand(arenaPad, H - arenaPad - h);
      state.beds.push({x,y,w,h,brown:false, cooldown:0});
    }
  }
  function spawnPower(){
    const kinds = ['time','dash','magnet'];
    const k = kinds[Math.floor(Math.random()*kinds.length)];
    const x = rand(arenaPad, W- arenaPad-24), y = rand(arenaPad, H- arenaPad-24);
    state.powerups.push({x,y,k,ttl:12});
  }

  // --- Input ---
  const keys = new Set();
  addEventListener('keydown', e=>{ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); keys.add(e.key.toLowerCase()); if(e.key===' ') tryBrown(); });
  addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));
  canvas.addEventListener('pointerdown', (e)=>{ const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)/rect.width*W; const y=(e.clientY-rect.top)/rect.height*H; clickAt({x,y}); });

  function clickAt(p){
    const b = state.beds.find(b=>!b.brown && p.x>=b.x && p.x<=b.x+b.w && p.y>=b.y && p.y<=b.y+b.h);
    if(b){ tryBrown(b); }
  }

  function tryBrown(target){
    const player = state.player;
    let best=null, bestD=Infinity;
    for(const b of state.beds){
      if(b.brown || b.cooldown>0) continue;
      if(target && b!==target) continue;
      const cx = clamp(player.x, b.x, b.x+b.w);
      const cy = clamp(player.y, b.y, b.y+b.h);
      const d = Math.hypot(player.x-cx, player.y-cy);
      const range = player.magnet>0 ? 60 : 38;
      if(d<range && d<bestD){ best=b; bestD=d; }
    }
    if(best){
      best.brown = true;
      best.cooldown = 1.0;
      state.score++;
      if(state.comboTimer>0) state.combo = Math.min(10, state.combo+1); else state.combo = 1;
      state.comboTimer = 1.2;
      const add = (state.combo>=7?1.1 : state.combo>=4?0.7 : 0.4);
      state.time = Math.min(99.9, state.time + add);
      if(Math.random()<0.55){
        const idx = state.beds.indexOf(best);
        const w = rand(60,100), h=rand(40,70);
        const x = rand(arenaPad, W - arenaPad - w);
        const y = rand(arenaPad, H - arenaPad - h);
        state.beds[idx] = {x,y,w,h,brown:false, cooldown:0};
      }
      AudioKit.success();
      particlesBurst(best.x+best.w/2, best.y+best.h/2, '#8b5e34');
      flash();
    } else {
      AudioKit.click();
    }
  }

  // --- Touch controls ---
  const joy = document.getElementById('joy');
  const stick = document.getElementById('stick');
  const act = document.getElementById('act');
  let joyActive=false;
  function setJoy(e){
    const r = joy.getBoundingClientRect();
    const p = {x: e.clientX - r.left, y: e.clientY - r.top};
    const cx = r.width/2, cy = r.height/2;
    const dx = p.x - cx, dy = p.y - cy;
    const len = Math.hypot(dx,dy);
    const max = r.width*0.36;
    const nx = (len>0? dx/len:0), ny=(len>0? dy/len:0);
    const mag = Math.min(1, len/max);
    stick.style.transform = `translate(${(nx*mag*max)}px, ${(ny*mag*max)}px)`;
    state.player.vx = nx*mag; state.player.vy = ny*mag;
  }
  joy.addEventListener('pointerdown', e=>{ joyActive=true; joy.setPointerCapture(e.pointerId); setJoy(e); });
  joy.addEventListener('pointermove', e=>{ if(joyActive) setJoy(e); });
  joy.addEventListener('pointerup', ()=>{ joyActive=false; state.player.vx=0; state.player.vy=0; stick.style.transform='translate(-50%,-50%)'; });
  act.addEventListener('pointerdown', ()=> tryBrown());

  // --- Visual FX ---
  let flashAlpha=0;
  function flash(){ flashAlpha = 0.22; }
  const particles=[];
  function particlesBurst(x,y,color){
    for(let i=0;i<10;i++){
      particles.push({x,y, vx:rand(-80,80), vy:rand(-120,-40), g:220, a:1, r:rand(2,4), color});
    }
  }

  // --- Resize handling ---
  function resize(){
    const wrap = document.getElementById('gameWrap');
    const rect = wrap.getBoundingClientRect();
    const ar = 16/10; // 16:10
    let w = rect.width, h = rect.width/ar;
    if(h>rect.height){ h = rect.height; w = h*ar; }
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
  }
  addEventListener('resize', resize); setTimeout(resize,0);

  // --- Game Loop ---
  function start(){
    state.running=true; state.time=60; state.score=0; state.combo=1; state.comboTimer=0; state.player.x=W/2; state.player.y=H/2; state.player.scatto=0; state.player.magnet=0; state.powerups=[]; spawnBeds(24); ui.start.style.display='none'; ui.over.style.display='none'; last = performance.now(); loop(last);
  }
  function gameOver(){
    state.running=false; ui.finalScore.textContent=state.score; if(state.score>state.best){ state.best=state.score; localStorage.setItem('bbb-best', String(state.best)); }
    ui.finalBest.textContent=state.best; ui.best.textContent=state.best; ui.over.style.display='grid';
  }
  let last = 0;
  function loop(t){
    if(!state.running) return;
    const dt = Math.min(0.033, (t - last)/1000); last = t;
    update(dt); draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    state.time -= dt; if(state.time<=0){ state.time=0; return gameOver(); }
    if(state.comboTimer>0){ state.comboTimer -= dt; if(state.comboTimer<=0){ state.combo=1; state.comboTimer=0; }}

    const p = state.player;
    let ax = 0, ay = 0;
    if(keys.has('arrowleft')||keys.has('a')) ax -= 1;
    if(keys.has('arrowright')||keys.has('d')) ax += 1;
    if(keys.has('arrowup')||keys.has('w')) ay -= 1;
    if(keys.has('arrowdown')||keys.has('s')) ay += 1;
    if(ax||ay){ const len=Math.hypot(ax,ay); ax/=len; ay/=len; }
    const tvx = p.vx || 0, tvy = p.vy || 0;
    let vx = ax + tvx, vy = ay + tvy;
    if(vx||vy){ const n=Math.hypot(vx,vy); vx/=n; vy/=n; }

    const spd = p.speed * (p.scatto>0?1.8:1);
    p.x += vx*spd*dt; p.y += vy*spd*dt;
    p.x = clamp(p.x, arenaPad, W-arenaPad); p.y = clamp(p.y, arenaPad, H-arenaPad);
    if(p.scatto>0) p.scatto -= dt; if(p.magnet>0) p.magnet -= dt;

    for(const b of state.beds){ if(b.cooldown>0){ b.cooldown -= dt; if(b.cooldown<0) b.cooldown=0; } }

    if(Math.random()<0.01 && state.powerups.length<3) spawnPower();
    for(const pow of state.powerups){ pow.ttl -= dt; }
    state.powerups = state.powerups.filter(p=>p.ttl>0);

    for(const pow of state.powerups){ if(Math.hypot(p.x-pow.x, p.y-pow.y)<24){
      if(pow.k==='time'){ state.time = Math.min(99.9, state.time+5); }
      if(pow.k==='dash'){ state.player.scatto = Math.max(state.player.scatto, 5); }
      if(pow.k==='magnet'){ state.player.magnet = Math.max(state.player.magnet, 8); }
      AudioKit.power(); pow.ttl=0; particlesBurst(pow.x,pow.y,'#60a5fa');
    }}

    for(const pt of particles){ pt.vy += pt.g*dt/60; pt.x += pt.vx*dt; pt.y += pt.vy*dt; pt.a -= 1.5*dt; }
    for(let i=particles.length-1;i>=0;i--){ if(particles[i].a<=0) particles.splice(i,1); }

    ui.time.textContent = state.time.toFixed(1);
    ui.score.textContent = state.score;
    ui.combo.textContent = 'x'+state.combo;
  }

  function draw(){
    ctx2d.clearRect(0,0,W,H);

    ctx2d.save();
    ctx2d.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx2d.lineWidth = 1;
    for(let x=arenaPad; x<W-arenaPad; x+=48){ ctx2d.beginPath(); ctx2d.moveTo(x,arenaPad); ctx2d.lineTo(x,H-arenaPad); ctx2d.stroke(); }
    for(let y=arenaPad; y<H-arenaPad; y+=48){ ctx2d.beginPath(); ctx2d.moveTo(arenaPad,y); ctx2d.lineTo(W-arenaPad,y); ctx2d.stroke(); }
    ctx2d.restore();

    for(const b of state.beds){
      const radius = 10;
      ctx2d.beginPath();
      roundRect(ctx2d, b.x, b.y, b.w, b.h, radius);
      ctx2d.fillStyle = b.brown? '#8b5e34' : '#334155';
      ctx2d.fill();
      ctx2d.lineWidth = b.brown? 2:1;
      ctx2d.strokeStyle = b.brown? '#a16207' : '#475569';
      ctx2d.stroke();
      // cuscino
      ctx2d.fillStyle = b.brown? '#7c3e1c' : '#e5e7eb';
      ctx2d.fillRect(b.x + b.w*0.1, b.y+6, b.w*0.8, 10);
    }

    for(const pow of state.powerups){
      ctx2d.save(); ctx2d.translate(pow.x, pow.y);
      ctx2d.beginPath(); ctx2d.arc(0,0,12,0,Math.PI*2);
      ctx2d.fillStyle = '#0b1228'; ctx2d.fill(); ctx2d.lineWidth=2; ctx2d.strokeStyle='#60a5fa'; ctx2d.stroke();
      ctx2d.fillStyle = '#60a5fa'; ctx2d.font = '12px system-ui'; ctx2d.textAlign='center'; ctx2d.textBaseline='middle';
      const icon = pow.k==='time'? '‚è±Ô∏è': pow.k==='dash'? 'üöÄ':'üß≤';
      ctx2d.fillText(icon, 0, 1);
      ctx2d.restore();
    }

    // player (Gianmarco)
    const p = state.player;
    ctx2d.save(); ctx2d.translate(p.x,p.y);
    // ombra
    ctx2d.beginPath(); ctx2d.ellipse(0,8,14,6,0,0,Math.PI*2); ctx2d.fillStyle='rgba(0,0,0,.35)'; ctx2d.fill();
    // corpo
    ctx2d.beginPath(); ctx2d.arc(0,0,16,0,Math.PI*2); ctx2d.fillStyle='#22c55e'; ctx2d.fill();
    // faccia
    ctx2d.fillStyle='#0b1228'; ctx2d.beginPath(); ctx2d.arc(-5,-4,2,0,Math.PI*2); ctx2d.arc(5,-4,2,0,Math.PI*2); ctx2d.fill();
    ctx2d.fillRect(-6,2,12,2);
    ctx2d.restore();

    // particelle
    for(const pt of particles){ ctx2d.globalAlpha = Math.max(0, pt.a); ctx2d.fillStyle = pt.color; ctx2d.beginPath(); ctx2d.arc(pt.x, pt.y, pt.r, 0, Math.PI*2); ctx2d.fill(); ctx2d.globalAlpha=1; }

    // flash overlay
    if(flashAlpha>0){ ctx2d.fillStyle = `rgba(245,158,11,${flashAlpha})`; ctx2d.fillRect(0,0,W,H); flashAlpha -= 0.03; if(flashAlpha<0) flashAlpha=0; }
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  }

  // --- Buttons ---
  document.getElementById('btnStart').addEventListener('click', ()=>{ AudioKit.click(); start(); });
  document.getElementById('btnHow').addEventListener('click', ()=>{ alert('Avvic√¨nati a un letto e premi SPAZIO (o il pulsante GO). Ogni combo ravvicinata aggiunge tempo. Raccogli power-up per facilitarti.'); });
  document.getElementById('btnAgain').addEventListener('click', ()=>{ AudioKit.click(); start(); });
  document.getElementById('btnShare').addEventListener('click', ()=>{
    const txt = `Ho reso marroni ${state.best} letti in Brown Bed Blitz! Prova a battermi!`;
    if(navigator.share){ navigator.share({title:'Brown Bed Blitz', text:txt}); }
    else { navigator.clipboard.writeText(txt); alert('Copiato negli appunti!'); }
  });
  document.getElementById('btnReset').addEventListener('click', ()=>{ localStorage.removeItem('bbb-best'); state.best=0; ui.best.textContent=0; });
  document.getElementById('btnMute').addEventListener('click', (e)=>{ const on = e.target.getAttribute('aria-pressed')==='true'; AudioKit.enable(!on); e.target.setAttribute('aria-pressed', String(!on)); e.target.textContent = !on? 'üîä Audio' : 'üîà Muto'; });
  document.getElementById('btnFullscreen').addEventListener('click', ()=>{ const elem = document.documentElement; try{ if(!document.fullscreenElement){ elem.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }catch(_){} });
  document.getElementById('btnTheme').addEventListener('click', ()=>{ document.body.style.filter = document.body.style.filter? '' : 'invert(1) hue-rotate(180deg)'; });

  // --- Minimal test runner ---
  const logEl = document.getElementById('testLog');
  const summaryEl = document.getElementById('testSummary');
  function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }
  function assert(name, cond){ if(cond){ pass++; log('‚úÖ ' + name); } else { fails++; log('‚ùå ' + name); } }
  let pass=0, fails=0;

  function resetTests(){ pass=fails=0; logEl.textContent=''; summaryEl.textContent='Esecuzione test‚Ä¶'; }

  function runTests(){
    resetTests();

    // Test 1: spawnBeds crea n letti dentro l'arena
    spawnBeds(10);
    let allInside = state.beds.every(b=> b.x>=arenaPad && b.y>=arenaPad && b.x+b.w<=W-arenaPad && b.y+b.h<=H-arenaPad);
    assert('spawnBeds() posiziona i letti entro i limiti', allInside && state.beds.length===10);

    // Test 2: tryBrown incrementa punteggio se vicino
    const bed = {x:100,y:100,w:80,h:50,brown:false,cooldown:0};
    state.beds=[bed]; state.player.x=120; state.player.y=110; state.player.magnet=0; state.score=0; state.time=10; state.combo=1; state.comboTimer=0;
    tryBrown();
    assert('tryBrown() rende marrone un letto vicino', bed.brown===true && state.score===1);

    // Test 3: combo & tempo aumentano
    const bed2 = {x:200,y:100,w:80,h:50,brown:false,cooldown:0};
    state.beds=[bed2]; state.player.x=210; state.player.y=110; state.comboTimer=0.6; const timeBefore=state.time; const comboBefore=state.combo;
    tryBrown();
    assert('Combo aumenta se in finestra', state.combo>comboBefore);
    assert('Tempo aumenta con combo', state.time>timeBefore);

    // Test 4: raccolta powerup tempo
    const pow = {x:state.player.x, y:state.player.y, k:'time', ttl:5};
    state.powerups=[pow]; const t0=state.time; update(0.016); // collision check avviene in update
    assert('Powerup tempo aggiunge secondi', state.time>t0);

    // Test 5: UI riflette lo stato
    ui.score.textContent=''; ui.time.textContent='';
    update(0.016);
    assert('UI aggiornata (score/time)', ui.score.textContent==String(state.score) && /\d+\.\d/.test(ui.time.textContent));

    // Test 6: guard MetaMask sopprime messaggio (error)
    const suppressedError = (function(){
      const ev = new Event('error'); ev.message = 'Failed to connect to MetaMask'; let prevented=false; ev.preventDefault = ()=>{prevented=true}; window.dispatchEvent(ev); return prevented;
    })();
    assert('Guard Web3 sopprime errori MetaMask (error)', suppressedError===true);

    // Test 7: guard MetaMask sopprime messaggio (unhandledrejection)
    const before = window.__web3SuppressedCount;
    const ev2 = new Event('unhandledrejection'); ev2.reason = new Error('Failed to connect to MetaMask'); let prevented2=false; ev2.preventDefault = ()=>{prevented2=true}; window.dispatchEvent(ev2);
    assert('Guard Web3 sopprime unhandledrejection', prevented2===true && window.__web3SuppressedCount===before+1);

    // Test 8: click lontano non cambia punteggio
    spawnBeds(1); const far = state.beds[0]; far.x=800; far.y=500; far.w=80; far.h=50; state.player.x=100; state.player.y=100; const s0=state.score; tryBrown();
    assert('Nessuna interazione fuori range', state.score===s0);

    // Test 9: game over quando tempo esaurito
    state.running=true; ui.over.style.display='none'; state.time=0.001; update(0.01);
    assert('Game over mostra overlay', ui.over.style.display==='grid');

    summaryEl.textContent = `Test superati: ${pass}, falliti: ${fails}`;
    if(fails===0) toast('Tutti i test passati ‚úÖ'); else toast('Alcuni test sono falliti ‚ùå');
  }
  document.getElementById('btnTests').addEventListener('click', runTests);

  // Nota: la schermata iniziale attende un gesto dell'utente per abilitare l'audio
  </script>
</body>
</html>
